"""
AD Password Audit Script
========================
REQUIRED SYSTEM PACKAGES:
    - impacket (specifically impacket-secretsdump)
    - hashcat
    - coreutils (cp, rm)

REQUIRED PIP PACKAGES:
    - pip install requests
    - pip install impacket

USAGE:
    Default (Everything): python3 ad_pass_audit.py
    Skip HIBP:            python3 ad_pass_audit.py --skip-hibp
    Skip Cracking:        python3 ad_pass_audit.py --skip-hashcat
"""

import subprocess
import os
import argparse
import csv
import hashlib
import requests
import time
from collections import Counter, defaultdict

# --- Configuration ---
CONFIG = {
    "ntds": "0.ntds.dit", 
    "system": "0.SYSTEM", 
    "security": "0.SECURITY", 
    "wordlist_basic": "1.basic_pass.txt", 
    "wordlist_full": "1.rockyou.txt", 
    "rules": "1.OneRuleToRuleThemStill.rule" 
}

CSV_CONFIG = {
    "include_plaintext": True,
    "cracked_csv": "5.cracked_accounts.csv",
    "groups_csv": "5.shared_password_groups.csv",
    "hash_file": "2.domain_users.hash",
    "basic_pot": "3.basic.potfile",
    "full_pot": "3.full.potfile",
    "quick_report": "4.quick_audit_report.txt",
    "deep_report": "4.deep_audit_report.txt"
}

def check_hibp_pwned(password):
    """Checks if a password has been seen in data breaches using k-Anonymity."""
    sha1_hex = hashlib.sha1(password.encode('utf-8')).hexdigest().upper()
    prefix = sha1_hex[:5]
    suffix = sha1_hex[5:]
    
    url = f"https://api.pwnedpasswords.com/range/{prefix}"
    
    try:
        response = requests.get(url, timeout=10)
        
        # Handle Rate Limiting (HTTP 429)
        if response.status_code == 429:
            print("[!] HIBP Rate limit hit. Waiting 2 seconds...")
            time.sleep(2)
            response = requests.get(url, timeout=10)

        if response.status_code != 200:
            return 0
        
        hashes = (line.split(':') for line in response.text.splitlines())
        for h, count in hashes:
            if h == suffix:
                return int(count)
    except Exception as e:
        print(f"[!] HIBP API Error: {e}")
    
    return 0

def run_cmd(cmd):
    return subprocess.run(cmd, capture_output=True, text=True)

def crack_recursive(hash_file, wordlist, iterations, potfile):
    print(f"[*] Starting recursive crack on {wordlist} ({iterations} rounds)...")
    current_wordlist = f"2.temp_{os.path.basename(wordlist)}"
    
    if not os.path.exists(wordlist):
        print(f"[!] Error: Wordlist {wordlist} not found.")
        return

    subprocess.run(["cp", wordlist, current_wordlist])

    for i in range(iterations):
        print(f"  > Round {i+1}...")
        subprocess.run([
            "hashcat", "-m", "1000", "-a", "0", hash_file, current_wordlist,
            "-r", CONFIG['rules'], "--potfile-path", potfile, "--force", "--quiet"
        ])
        
        if os.path.exists(potfile):
            with open(potfile, "r", errors="ignore") as p:
                new_pws = [line.split(":")[1].strip() for line in p if ":" in line]
            if new_pws:
                with open(current_wordlist, "a", errors="ignore") as cw:
                    for pw in set(new_pws):
                        cw.write(pw + "\n")
    
    if os.path.exists(current_wordlist):
        os.remove(current_wordlist)

def export_audit_data(basic_pot, full_pot, hash_file, skip_hibp=False):
    """Parses hashes and potfiles to generate actionable CSV reports."""
    print("[*] Generating CSV export files...")
    
    cracked_lookup = {}
    for pot in [basic_pot, full_pot]:
        if os.path.exists(pot):
            with open(pot, "r", errors="ignore") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts) >= 2:
                        cracked_lookup[parts[0]] = parts[1]

    cracked_users = []
    hash_groups = defaultdict(list)

    if not os.path.exists(hash_file):
        print(f"[!] Error: Hash file {hash_file} not found for export.")
        return

    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4:
                username, rid, nt_hash = parts[0], parts[1], parts[3]
                hash_groups[nt_hash].append(username)
                
                if nt_hash in cracked_lookup:
                    cracked_users.append({
                        "Username": username, "RID": rid,
                        "Password": cracked_lookup[nt_hash], "NT_Hash": nt_hash
                    })

    field_names = ["Username", "RID", "NT_Hash"]
    if CSV_CONFIG["include_plaintext"]: field_names.insert(2, "Password")
    
    # HIBP is now default unless --skip-hibp is used
    if not skip_hibp: 
        field_names.append("HIBP_Pwned_Count")

    with open(CSV_CONFIG["cracked_csv"], "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=field_names, extrasaction='ignore')
        writer.writeheader()
        for user in cracked_users:
            if not skip_hibp:
                print(f"[*] Querying HIBP for: {user['Username']}")
                user["HIBP_Pwned_Count"] = check_hibp_pwned(user["Password"])
                time.sleep(0.1) 
            writer.writerow(user)

    with open(CSV_CONFIG["groups_csv"], "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["NT_Hash", "UserCount", "Users", "Cracked_Status"])
        for nt_hash, users in hash_groups.items():
            if len(users) > 1:
                status = (cracked_lookup[nt_hash] if nt_hash in cracked_lookup else "UNCRACKED")
                if not CSV_CONFIG["include_plaintext"] and status != "UNCRACKED": status = "[REDACTED]"
                writer.writerow([nt_hash, len(users), ", ".join(users), status])

def generate_report(potfile, hash_file, label, output_file):
    """Generates a summary report and saves it to a file."""
    if not os.path.exists(hash_file):
        return

    all_hashes = []
    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4: all_hashes.append(parts[3])

    total_accounts = len(all_hashes)
    hash_counts = Counter(all_hashes)
    shared_hash_users = sum(count for count in hash_counts.values() if count > 1)

    cracked_lookup = {}
    if os.path.exists(potfile):
        with open(potfile, "r", errors="ignore") as f:
            for line in f:
                parts = line.strip().split(":")
                if len(parts) >= 2: cracked_lookup[parts[0]] = parts[1]

    all_cracked = [cracked_lookup[h] for h in all_hashes if h in cracked_lookup]
    counts = Counter(all_cracked)

    report_lines = [
        "="*55,
        f"      {label} AUDIT REPORT",
        "="*55,
        f"Total Accounts Audited:   {total_accounts}",
        f"Total Shared Hashes:      {shared_hash_users}",
        f"Total Cracked Accounts:   {len(all_cracked)}",
        ""
    ]
    
    if all_cracked:
        report_lines.append("[+] Top 15 Shared Cracked Passwords:")
        report_lines.append(f"{'Count':<8} | {'Password'}")
        report_lines.append("-" * 35)
        for pw, count in counts.most_common(15):
            display_pw = pw if pw.strip() else "<BLANK/SPACE>"
            report_lines.append(f"{count:<8} | {display_pw}")

    report_content = "\n".join(report_lines)
    print(report_content)
    
    with open(output_file, "w") as rf:
        rf.write(report_content)
    print(f"[+] Report saved to: {output_file}")

def main():
    parser = argparse.ArgumentParser(description="Lean AD Password Auditor")
    parser.add_argument("--skip-extract", action="store_true", help="Skip impacket extraction")
    parser.add_argument("--skip-hashcat", action="store_true", help="Skip cracking process")
    parser.add_argument("--skip-hibp", action="store_true", help="Skip Have I Been Pwned check")
    args = parser.parse_args()

    hash_file = CSV_CONFIG["hash_file"]
    basic_pot = CSV_CONFIG["basic_pot"]
    full_pot = CSV_CONFIG["full_pot"]

    # 1. Extraction
    if not args.skip_extract:
        print("[*] Extracting hashes...")
        cmd = ["impacket-secretsdump", "-ntds", CONFIG['ntds'], "-system", CONFIG['system'], "-security", CONFIG['security'], "-user-status", "LOCAL"]
        result = run_cmd(cmd)
        with open(hash_file, "w") as f:
            for line in result.stdout.splitlines():
                if ":::" in line and "$" not in line: f.write(line + "\n")

    # 2. Cracking
    if not args.skip_hashcat:
        crack_recursive(hash_file, CONFIG['wordlist_basic'], 6, basic_pot)
        
        if os.path.exists(basic_pot):
            with open(basic_pot, "r", errors="ignore") as f:
                seeds = {line.strip().split(":")[1] for line in f if ":" in line}
            if seeds:
                temp_full = "3.temp_full_seeded.txt"
                with open(temp_full, "w", encoding="utf-8", errors="ignore") as f_out:
                    f_out.write("\n".join(seeds) + "\n")
                    with open(CONFIG['wordlist_full'], "r", encoding="utf-8", errors="ignore") as f_in:
                        for line in f_in: f_out.write(line)
                os.replace(temp_full, CONFIG['wordlist_full'])
        
        crack_recursive(hash_file, CONFIG['wordlist_full'], 2, full_pot)

    # 3. Reporting & Export
    generate_report(basic_pot, hash_file, "PHASE 1 (QUICK)", CSV_CONFIG["quick_report"])
    generate_report(full_pot, hash_file, "PHASE 2 (DEEP)", CSV_CONFIG["deep_report"])
    
    # Export data with the HIBP logic flipped
    export_audit_data(basic_pot, full_pot, hash_file, skip_hibp=args.skip_hibp)

    print(f"\n[!] Audit Complete.")

if __name__ == "__main__":
    main()
