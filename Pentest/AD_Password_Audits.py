import subprocess
import os
import datetime
import argparse
from collections import Counter

# --- Configuration ---
CONFIG = {
    "ntds": "ntds.dit",
    "system": "SYSTEM",
    "security": "SECURITY",
    "wordlist_basic": "basic_pass.txt",
    "wordlist_full": "rockyou.txt",
    "rules": "OneRuleToRuleThemStill.rule",
    "stale_days": 90
}

def run_cmd(cmd):
    """Runs a command and returns the result object."""
    return subprocess.run(cmd, capture_output=True, text=True)

def get_stale_accounts(raw_output):
    """Parses secretsdump text to find accounts inactive for 90+ days."""
    print(f"[*] Identifying Stale Accounts (>{CONFIG['stale_days']} Days)...")
    stale_users = []
    current_user = None
    threshold = datetime.datetime.now() - datetime.timedelta(days=CONFIG['stale_days'])

    for line in raw_output.splitlines():
        if "Name:" in line:
            current_user = line.split("Name:")[1].strip()
        
        if "lastLogonTimestamp:" in line and current_user:
            try:
                date_str = line.split("lastLogonTimestamp:")[1].strip()
                logon_date = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
                if logon_date < threshold:
                    stale_users.append(f"{current_user} (Last Login: {date_str})")
            except (ValueError, IndexError):
                continue
    return stale_users

def crack_recursive(hash_file, wordlist, iterations, potfile):
    """Recursive cracking: Appends cracked passwords back into the wordlist."""
    print(f"[*] Starting recursive crack on {wordlist} ({iterations} rounds)...")
    current_wordlist = f"temp_{os.path.basename(wordlist)}"
    
    if not os.path.exists(wordlist):
        print(f"[!] Error: Wordlist {wordlist} not found.")
        return

    # Initialize working wordlist
    subprocess.run(["cp", wordlist, current_wordlist])

    for i in range(iterations):
        print(f"  > Round {i+1}...")
        subprocess.run([
            "hashcat", "-m", "1000", "-a", "0", hash_file, current_wordlist,
            "-r", CONFIG['rules'], "--potfile-path", potfile, "--force", "--username", "--quiet"
        ])
        
        # Read potfile and feed new plaintexts back into the wordlist for the next round
        if os.path.exists(potfile):
            with open(potfile, "r") as p:
                new_pws = [line.split(":")[1].strip() for line in p if ":" in line]
            if new_pws:
                with open(current_wordlist, "a") as cw:
                    for pw in set(new_pws):
                        cw.write(pw + "\n")
    
    if os.path.exists(current_wordlist):
        os.remove(current_wordlist)

def generate_report(potfile, hash_file, label):
    """
    Comprehensive Reporting Logic:
    1. Analyzes total hash duplicates (Cracked + Uncracked).
    2. Maps cracked hashes back to users for plaintext analysis.
    """
    if not os.path.exists(hash_file):
        print(f"[!] Error: Original hash file {hash_file} missing. Cannot map users.")
        return

    # --- PART 1: GLOBAL HASH ANALYSIS (Cracked + Uncracked) ---
    all_hashes = []
    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4:
                # NTLM hash is the 4th field in secretsdump output
                all_hashes.append(parts[3])

    total_accounts = len(all_hashes)
    hash_counts = Counter(all_hashes)
    
    # Calculate totals for shared hashes
    # (Number of users who have a password identical to at least one other user)
    shared_hash_total_users = sum(count for count in hash_counts.values() if count > 1)
    unique_shared_hash_groups = sum(1 for count in hash_counts.values() if count > 1)

    # --- PART 2: CRACKED PASSWORD ANALYSIS ---
    cracked_lookup = {}
    if os.path.exists(potfile):
        with open(potfile, "r") as f:
            for line in f:
                parts = line.strip().split(":")
                if len(parts) >= 2:
                    # potfile format is hash:password
                    cracked_lookup[parts[0]] = parts[1]

    all_cracked_instances = []
    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4:
                ntlm_hash = parts[3]
                if ntlm_hash in cracked_lookup:
                    all_cracked_instances.append(cracked_lookup[ntlm_hash])

    # --- PART 3: OUTPUT GENERATION ---
    print(f"\n" + "="*50)
    print(f"      {label} AUDIT COMPLIANCE REPORT")
    print("="*50)
    
    print(f"[!] GLOBAL SECURITY METRICS (All Hashes):")
    print(f"  - Total Accounts Audited:     {total_accounts}")
    print(f"  - Total Users Sharing Hashes: {shared_hash_total_users}")
    print(f"  - Unique Shared Hash Groups:  {unique_shared_hash_groups}")
    if total_accounts > 0:
        share_pct = (shared_hash_total_users / total_accounts) * 100
        print(f"  - Shared Password Rate:       {share_pct:.2f}%")

    if not all_cracked_instances:
        print(f"\n--- {label} AUDIT: No cracked accounts found to analyze in this set ---")
        return

    # Calculations for cracked data
    counts = Counter(all_cracked_instances)
    lengths = [len(p) for p in all_cracked_instances]

    print(f"\n[+] CRACKING DISCOVERY:")
    print(f"  - Total Accounts Cracked:     {len(all_cracked_instances)}")
    print(f"  - Unique Passwords Found:     {len(counts)}")
    
    print("\n[+] TOP SHARED CRACKED PASSWORDS (Identity Confirmed):")
    for pw, count in counts.most_common(10):
        display = "<BLANK>" if pw == "" else pw
        print(f"  - {count:4} users share: {display}")

    print("\n[+] PASSWORD LENGTH DISTRIBUTION (Cracked Only):")
    for length in sorted(set(lengths)):
        print(f"  - {length:2} chars: {lengths.count(length)} users")

def main():
    parser = argparse.ArgumentParser(description="AD Password Audit Orchestrator")
    parser.add_argument("--skip-extract", action="store_true", help="Skip secretsdump extraction")
    parser.add_argument("--skip-hashcat", action="store_true", help="Skip the cracking phase")
    args = parser.parse_args()

    hash_file = "domain_users.hash"
    basic_pot = "basic.potfile"
    full_pot = "full.potfile"
    stale_users = []

    # 1. Extraction Phase
    if args.skip_extract:
        print("[*] Skipping extraction. Using existing hash file...")
        if not os.path.exists(hash_file):
            print(f"[!] Error: {hash_file} not found.")
            return
    else:
        print("[*] Exporting hashes from NTDS...")
        cmd = [
            "impacket-secretsdump", 
            "-ntds", CONFIG['ntds'], 
            "-system", CONFIG['system'], 
            "-security", CONFIG['security'],
            "-user-status", "LOCAL"
        ]
        result = run_cmd(cmd)
        stale_users = get_stale_accounts(result.stdout)
        
        with open(hash_file, "w") as fout:
            for line in result.stdout.splitlines():
                if ":::" in line and "$" not in line and "[*]" not in line:
                    fout.write(line + "\n")
        print(f"[+] Extraction complete. {hash_file} created.")

    # 2. Cracking Phase
    if args.skip_hashcat:
        print("[*] Skipping Hashcat phase...")
    else:
        # Phase A: Basic Crack
        crack_recursive(hash_file, CONFIG['wordlist_basic'], 5, basic_pot) #update number of iterations for Basic

        # SEEDING STEP: Feed Basic results into the Full wordlist
        if os.path.exists(basic_pot):
            print("[*] Seeding Basic results into Full wordlist...")
            with open(basic_pot, "r") as f:
                # Extract plaintexts from potfile (hash:password)
                seeds = {line.strip().split(":")[1] for line in f if ":" in line}
            
            if seeds:
                # Append unique seeds to the full wordlist
                with open(CONFIG['wordlist_full'], "a") as f_wordlist:
                    for s in seeds:
                        f_wordlist.write(s + "\n")
                print(f"[+] Added {len(seeds)} successful patterns to {CONFIG['wordlist_full']}")

        # Phase B: Full Crack (Now enriched with Basic results)
        crack_recursive(hash_file, CONFIG['wordlist_full'], 2, full_pot) #update number of iterations for Full

    # 3. Reporting Phase
    generate_report(basic_pot, hash_file, "BASIC (Common)")
    generate_report(full_pot, hash_file, "FULL (Extended)")

    if stale_users:
        print("\n[+] STALE ACCOUNTS (>90 Days Inactive):")
        for user in stale_users:
            print(f"  - {user}")

if __name__ == "__main__":
    main()
