import subprocess
import os
import argparse
import csv
from collections import Counter, defaultdict

# --- Configuration ---
CONFIG = {
    "ntds": "0.ntds.dit", #UPDATE to your corresponding file name / Path
    "system": "0.SYSTEM", #UPDATE to your corresponding file name / Path
    "security": "0.SECURITY", #UPDATE to your corresponding file name / Path
    "wordlist_basic": "1.basic_pass.txt", #UPDATE to your corresponding file name / Path
    "wordlist_full": "1.rockyou.txt", #UPDATE to your corresponding file name / Path
    "rules": "1.OneRuleToRuleThemStill.rule" #UPDATE to your corresponding file name / Path
}

# --- CSV & Reporting Settings ---
CSV_CONFIG = {
    "include_plaintext": False,  # Set to True to include passwords in CSVs
    "cracked_csv": "5.cracked_accounts.csv",
    "groups_csv": "5.shared_password_groups.csv",
    "hash_file": "2.domain_users.hash",
    "basic_pot": "3.basic.potfile",
    "full_pot": "3.full.potfile"
}

def run_cmd(cmd):
    return subprocess.run(cmd, capture_output=True, text=True)

def crack_recursive(hash_file, wordlist, iterations, potfile):
    print(f"[*] Starting recursive crack on {wordlist} ({iterations} rounds)...")
    current_wordlist = f"2.temp_{os.path.basename(wordlist)}"
    
    if not os.path.exists(wordlist):
        print(f"[!] Error: Wordlist {wordlist} not found.")
        return

    subprocess.run(["cp", wordlist, current_wordlist])

    for i in range(iterations):
        print(f"  > Round {i+1}...")
        subprocess.run([
            "hashcat", "-m", "1000", "-a", "0", hash_file, current_wordlist,
            "-r", CONFIG['rules'], "--potfile-path", potfile, "--force", "--quiet"
        ])
        
        if os.path.exists(potfile):
            with open(potfile, "r", errors="ignore") as p:
                new_pws = [line.split(":")[1].strip() for line in p if ":" in line]
            if new_pws:
                with open(current_wordlist, "a", errors="ignore") as cw:
                    for pw in set(new_pws):
                        cw.write(pw + "\n")
    
    if os.path.exists(current_wordlist):
        os.remove(current_wordlist)

def export_audit_data(basic_pot, full_pot, hash_file):
    """Parses hashes and potfiles to generate actionable CSV reports."""
    print("[*] Generating CSV export files...")
    
    # 1. Load all cracked passwords into a single lookup
    cracked_lookup = {}
    for pot in [basic_pot, full_pot]:
        if os.path.exists(pot):
            with open(pot, "r", errors="ignore") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts) >= 2:
                        cracked_lookup[parts[0]] = parts[1]

    # 2. Parse the hash file and group data
    cracked_users = []
    hash_groups = defaultdict(list)

    if not os.path.exists(hash_file):
        print(f"[!] Error: Hash file {hash_file} not found for export.")
        return

    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4:
                username = parts[0]
                rid = parts[1]
                nt_hash = parts[3]
                
                hash_groups[nt_hash].append(username)
                
                if nt_hash in cracked_lookup:
                    cracked_users.append({
                        "Username": username,
                        "RID": rid,
                        "Password": cracked_lookup[nt_hash],
                        "NT_Hash": nt_hash
                    })

    # 3. Determine fieldnames based on variable for Cracked Accounts
    field_names = ["Username", "RID", "NT_Hash"]
    if CSV_CONFIG["include_plaintext"]:
        field_names.insert(2, "Password")

    # 4. Write Cracked Users CSV
    with open(CSV_CONFIG["cracked_csv"], "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=field_names, extrasaction='ignore')
        writer.writeheader()
        writer.writerows(cracked_users)

    # 5. Write Hash Grouping CSV with conditional password hiding
    with open(CSV_CONFIG["groups_csv"], "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["NT_Hash", "UserCount", "Users", "Cracked_Status"])
        for nt_hash, users in hash_groups.items():
            if len(users) > 1:
                if nt_hash in cracked_lookup:
                    status = cracked_lookup[nt_hash] if CSV_CONFIG["include_plaintext"] else "[REDACTED]"
                else:
                    status = "UNCRACKED"
                
                writer.writerow([nt_hash, len(users), ", ".join(users), status])

    print(f"[+] Export Complete: '{CSV_CONFIG['cracked_csv']}' and '{CSV_CONFIG['groups_csv']}' created.")

def generate_report(potfile, hash_file, label):
    if not os.path.exists(hash_file):
        print(f"[!] Error: {hash_file} missing.")
        return

    all_hashes = []
    with open(hash_file, "r") as f:
        for line in f:
            parts = line.strip().split(":")
            if len(parts) >= 4:
                all_hashes.append(parts[3])

    total_accounts = len(all_hashes)
    hash_counts = Counter(all_hashes)
    shared_hash_users = sum(count for count in hash_counts.values() if count > 1)

    cracked_lookup = {}
    if os.path.exists(potfile):
        with open(potfile, "r", errors="ignore") as f:
            for line in f:
                parts = line.strip().split(":")
                if len(parts) >= 2:
                    cracked_lookup[parts[0]] = parts[1]

    all_cracked = [cracked_lookup[h] for h in all_hashes if h in cracked_lookup]
    counts = Counter(all_cracked)

    print("\n" + "="*55)
    print(f"      {label} AUDIT REPORT")
    print("="*55)
    print(f"Total Accounts Audited:   {total_accounts}")
    print(f"Total Shared Hashes:      {shared_hash_users}")
    print(f"Total Cracked Accounts:   {len(all_cracked)}")
    
    if all_cracked:
        print(f"\n[+] Top 10 Shared Cracked Passwords:")
        print(f"{'Count':<8} | {'Password'}")
        print("-" * 35)
        for pw, count in counts.most_common(10):
            display_pw = pw if pw.strip() else "<BLANK/SPACE>"
            print(f"{count:<8} | {display_pw}")

def main():
    parser = argparse.ArgumentParser(description="Lean AD Password Auditor")
    parser.add_argument("--skip-extract", action="store_true")
    parser.add_argument("--skip-hashcat", action="store_true")
    args = parser.parse_args()

    hash_file = CSV_CONFIG["hash_file"]
    basic_pot = CSV_CONFIG["basic_pot"]
    full_pot = CSV_CONFIG["full_pot"]

    # 1. Extraction
    if not args.skip_extract:
        print("[*] Extracting hashes...")
        cmd = ["impacket-secretsdump", "-ntds", CONFIG['ntds'], "-system", CONFIG['system'], "-security", CONFIG['security'], "-user-status", "LOCAL"]
        result = run_cmd(cmd)
        with open(hash_file, "w") as f:
            for line in result.stdout.splitlines():
                if ":::" in line and "$" not in line:
                    f.write(line + "\n")

    # 2. Cracking
    if not args.skip_hashcat:
        crack_recursive(hash_file, CONFIG['wordlist_basic'], 6, basic_pot) #UPDATE number to change iterations
        
        if os.path.exists(basic_pot):
            with open(basic_pot, "r", errors="ignore") as f:
                seeds = {line.strip().split(":")[1] for line in f if ":" in line}
            if seeds:
                print(f"[*] Seeding {len(seeds)} passwords into {CONFIG['wordlist_full']}...")
                temp_full = "3.temp_full_seeded.txt"
                with open(temp_full, "w", encoding="utf-8", errors="ignore") as f_out:
                    f_out.write("\n".join(seeds) + "\n")
                    with open(CONFIG['wordlist_full'], "r", encoding="utf-8", errors="ignore") as f_in:
                        for line in f_in:
                            f_out.write(line)
                os.replace(temp_full, CONFIG['wordlist_full'])
        
        crack_recursive(hash_file, CONFIG['wordlist_full'], 2, full_pot) #UPDATE number to change iterations

    # 3. Reporting & Export
    generate_report(basic_pot, hash_file, "PHASE 1 (QUICK)")
    generate_report(full_pot, hash_file, "PHASE 2 (DEEP)")
    export_audit_data(basic_pot, full_pot, hash_file)

    print(f"\n[!] Audit Complete.")
    #print(f"[*] To enforce resets: Import-Csv .\\{CSV_CONFIG['cracked_csv']} | ForEach-Object {{ Set-ADUser -Identity $_.Username -ChangePasswordAtLogon $true }}")

if __name__ == "__main__":
    main()
